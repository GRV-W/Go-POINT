# 组合索引的最左匹配原则

## 前言

对于组合索引我们知道，在使用的时候有一个最左前缀的原则，除了这些呢，比如字段放置的位置，
会不会对索引的效率产生影响呢？

## 最左匹配原则

联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：
````
create table test
(
    id       bigint not null
        constraint test_pk
            primary key,
    column_1 bigint,
    column_2 bigint,
    column_3 bigint
);

create unique index test_id_uindex
    on test (id);

create index test_column_1_column_2_column_3_index
    on test (column_1, column_2, column_3);
````
比如上面的test表，我们建立了联合索引``index test_column_1_column_2_column_3_index on test (column_1, column_2, column_3);``
当我们进行查询的时候，按照最左前缀的原则，当查询(column_1)、(column_1,column_2)、(column_1,column_2,column_3)这三种组合是可以用到
我们定义的联合索引的。如果我们查询(column_1,column_3)就只能用到column_1的索引了。我们不用太关心索引的先后顺序，什么意思呢？
比如使用(column_1,column_2)和(column_2,column_1)的效果是一样的，数据库的查询优化器会自动帮助我们优化我们的sql，看哪个执行的效率最高，
最后才生成最后执行的sql。

为什么会有最左前缀呢？  

当使用b+树作为索引的存储数据结构时，当我们创建联合索引的时候，比如(column_1, column_2, column_3)，b+树建立索引是从左
到右来建立搜索树的，比如当我们来查询的时候``WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 3``。b+树会先通过最
左边的（建立索引的字段的左边的字段）字段，也就是``column_1``来确定下一步的查找对象，然后找到column_2，在通过column_2的
索引找到column_3。所以(column_2,column_3)这样的查询命中不到索引了。因为最左前缀，一定是从最左边的字段开始依次在b+树的子节点
查询，然后确定下一个查找的子节点的数据。所以我们(column_1)、(column_1,column_2)、(column_1,column_2,column_3)这三种查询
条件是可以使用到索引的。





### 参考
【最左匹配原则的理解】https://blog.csdn.net/u013164931/article/details/82386555  