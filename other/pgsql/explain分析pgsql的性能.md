## EXPLAIN分析pgsql的性能

### 前言

对于pgsql中查询性能的分析，好像不想mysql中那么简单。当然pgsql中也是通过EXPLAIN进行
分析，那么就来认真中结下pgsql中explain的使用。

### EXPLAIN命令

#### EXPLAIN -- 显示一个语句的执行计划

````
EXPLAIN [ ( option [, ...] ) ] statement
EXPLAIN [ ANALYZE ] [ VERBOSE ] statement

这里 option可以是：

    ANALYZE [ boolean ]
    VERBOSE [ boolean ]
    COSTS [ boolean ]
    BUFFERS [ boolean ]
    TIMING [ boolean ]
    FORMAT { TEXT | XML | JSON | YAML }
````
ANALYZE选项通过实际执行的sql来获取相应的计划。这个是真正执行的，多以可以真是的看到执行计划花费了多少的时间，还有它返回的行数。  

当然对于分析插入更新的语句，我们我们是可以把ANALYZE放到事物里面的，分析后之后回滚。  

````
BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;
````

#### VERBOSE

VERBOSE选项用于显示计划的附加信息。这些附加的信息有：计划中每个节点输出的各个列，如果触发器被触发，还会输出触发器的名称。该选项默认为FALSE。

COSTS选项显示每个计划节点的启动成本和总成本，以及估计行数和每行宽度。该选项默认是TRUE。

BUFFERS选项显示关于缓存区的信息。该选项只能与ANALYZE参数一起使用。显示的缓存区信息包括共享快块，本地块和临时读和写的块数。共享块、本地块和临时块分别
包含表和索引、临时快和临时索引、以及在排序和物化计划中使用的磁盘块。上层节点显示出来的数据块包含其所有子节点使用的块数。该选项默认为FALSE。

#### 全表扫描

全表扫描在pgsql中叫做顺序扫描(seq scan)，全表扫描就是把表的的所有的数据从头到尾读取一遍，然后从数据块中找到符合条件的数据块。


#### 索引扫描

索引是为了加快数据查询的速度索引而增加的(Index Scan)。索引扫描也就是我们的查询条件使用到了我们创建的索引，当然什么是索引，自行查阅资料吧。

#### 位图扫描

位图扫描也是走索引的一种方式。方法是扫描索引，那满足条件的行或者块在内存中建立一个位图，扫描完索引后，再根据位图到表的数据文件中把相应的数据读出来。
如果走了两个索引，可以把两个索引进行’and‘或‘or’计算，合并到一个位图，再到表的数据文件中把数据读出来。  

#### 条件过滤

就是在where后面加上过滤条件，扫描数据行，会找出满足条件过滤的行。条件过滤执行计划中显示为‘Filter’。

#### Nestloop join

对于被连接的数据子集较小的情况，`Nested Loop`是个较好的选择。`Nested Loop`是连表查询最朴素的一种连接方式。在嵌套循环的时候，内表被外表驱动，外表中返回的每一
行，都要在内表中检索找寻和它匹配的行。整个查询返回的结果集不能太大（>10000不适合），要把返回子集比较小的表作为外表，同时内表中连接查询的字段，最好能命中索
引，不然会有性能问题。  

执行的过程：确定一个驱动表（outer table），另一个表为inner table，驱动表中的每一行数据会去inner表中，查找检索数据。注意，驱动表的每一行都去inner表中
检索，索引驱动表的数据不能太大。对于inner表中的数据就没有限制了，只要创建的索引合适，inner表中数据的大小对查询的性能影响不大。

#### Hash join

优化器使用两个表较小的表，并利用连接键在内存中建立散列表，然后扫描较大的表并探测散列表，找出与散列表匹配的列。  

这种方式适用于较小的表可以完全放入到内存中，这样总成本就是访问两个表的成本之和。但是如果表都很大，不能放入到内存中，优化器会将它分割成若干个不同的分区，把不能放入到内存的
部分写入到临时段。此时要求有较大的临时段从而尽量提高I/O 的性能。它能够很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。

优化器会自动选择较小的表，建立散列表，然后扫描另个较大的表。`Hash Join`只能应用于等值连接(如WHERE A.COL3 = B.COL4)，这是由Hash的特点决定的。  

测试下  

#### Merge Join

通常情况下散列连接的效果比合并连接的效果好，如果源数据上有索引，或者结果已经排过序，在执行顺序合并连接时就不需要排序了，这时合并连接的性能会优于散列连接。  

`Merge join`的操作步骤：  
1' 对连接的每个表做table access full;  
2' 对table access full的结果进行排序;  
3' 进行merge join对排序结果进行合并。  

`Merge Join`可适于于非等值Join（>，<，>=，<=，但是不包含!=，也即<>）  

#### Nested Loop，Hash JOin，Merge Join对比


|     类别                |     Nested Loop                | Hash Join                      |             Merge Join         |
| -----------------------| -------------------------------| -------------------------------| -------------------------------|
| 使用条件                | 任何条件                        | 等值连接（=）                    | 等值或非等值连接(>，<，=，>=，<=)，‘<>’除外              |
| 相关资源                | CPU、磁盘I/O                     | 内存、临时空间                    | 内存、临时空间               |
| 特点                   | 当有高选择性索引或进行限制性搜索时效率比较高，能够快速返回第一次的搜索结果。|当缺乏索引或者索引条件模糊时，Hash Join比Nested Loop有效。通常比Merge Join快。在数据仓库环境下，如果表的纪录数多，效率高。|当缺乏索引或者索引条件模糊时，Merge Join比Nested Loop有效。非等值连接时，Merge Join比Hash Join更有效|
| 缺点                   | 当索引丢失或者查询条件限制不够时，效率很低；当表的纪录数多时，效率低。|为建立哈希表，需要大量内存。第一次的结果返回较慢。|所有的表都需要排序。它为最优化的吞吐量而设计，并且在结果没有全部找到前不返回数据。|




### 参考
【EXPLAIN】http://www.postgres.cn/docs/9.5/sql-explain.html  


