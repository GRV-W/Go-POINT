## pgsql中的事务隔离级别

### 前言

最近在学习pgsql里面的锁，但是忽然发现对于事物的隔离有点模糊，不能很好的进行知识的串联。那么就来认真总结下吧。


### 事物隔离级别

这是官方文档的描述
>SQL标准定义了四种隔离级别。最严格的是可序列化，在标准中用了一整段来定义它，其中说到一组可序列化事务的任意并发执行被保证效果和以某种顺序一个一个执行这些事务一样。其他三种级别使用并发事务之间交互产生的现象来定义，每一个级别中都要求必须不出现一种现象。注意由于可序列化的定义，在该级别上这些现象都不可能发生（这并不令人惊讶--如果事务的效果与每个时刻只运行一个的相同，你怎么可能看见由于交互产生的现象？）。

四种事务隔离级别分别是：  
读未提交  
读已提交  
可重复读  
可序列化  

#### 在各个级别上被禁止出现的现象是

##### 脏读

一个事物读取了另一个并行未提交事物写入的数据。

##### 不可重复读

一个事物重新读取之前的数据，发现这个数据已经被另一个事物（在初读之后提交）修改。

##### 幻读

一个事物重新执行了一个返回符合条件的行集合的查询，发现满足条件的行集合因为另一个最近提交的事物发生了改变。

##### 序列化异常

成功提交一组事物的结果与这些事物所有可能串行执行结果不一致。

![](https://img2020.cnblogs.com/blog/1237626/202004/1237626-20200408173711728-1923933673.png)

在PostgreSQL中，你可以请求四种标准事务隔离级别中的任意一种，但是内部只实现了三种不同的隔离级别，即 PostgreSQL 的读未提交模式的行为和读已提交相同。这是因为把标准隔离级别映射到 PostgreSQL 的多版本并发控制架构的唯一合理的方法。

### 读已提交隔离级别

****读已提交是pgsql中默认的隔离级别。****当一个事务使用这个隔离级别时，一个查询（没有FOR UPDATE/SHARE子句）只能看到查询开始之前已经
被提交的数据，而无法看到未提交的数据或在查询执行期间其他事物提交的数据。

****在不同的事务之间****：SELECT查询看到的是一个在查询开始运行的瞬间该数据库的一个快照，当一个事务a对数据进行了修改，a事务还没有提交的时候另一个事务b查询到的数据就是，事务a未修改之前的数据，也就是查询开始之前的瞬间，数据库的一个快照。  
****在同一个事务之间****：SELECT可以看见在它自身事务中之前执行的更新的效果，即使它们还没有被提交。也就是更新完成之后的数据，是马上可以被查询到的，这就造成了，在同一个事务之间先后查询的结果可能不一样，当更新操作在两个查询之间进行，后面的查询就是更新后的数据了。  





### 参考
