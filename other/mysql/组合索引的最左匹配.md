# 组合索引的最左匹配原则

## 前言

对于组合索引我们知道，在使用的时候有一个最左前缀的原则，除了这些呢，比如字段放置的位置，
会不会对索引的效率产生影响呢？

## 最左匹配原则

联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配，示例：
````
create table test
(
    id       bigint auto_increment
        primary key,
    column_1 bigint null,
    column_2 bigint null,
    column_3 bigint null
);

create index test_column_1_column_2_column_3_index
    on test (column_1, column_2, column_3);
````
比如上面的test表，我们建立了联合索引``index test_column_1_column_2_column_3_index on test (column_1, column_2, column_3);``
当我们进行查询的时候，按照最左前缀的原则，当查询(column_1)、(column_1,column_2)、(column_1,column_2,column_3)这三种组合是可以用到
我们定义的联合索引的。如果我们查询(column_1,column_3)就只能用到column_1的索引了。我们不用太关心索引的先后顺序，什么意思呢？
比如使用(column_1,column_2)和(column_2,column_1)的效果是一样的，数据库的查询优化器会自动帮助我们优化我们的sql，看哪个执行的效率最高，
最后才生成最后执行的sql。

#### 为什么会有最左前缀呢？  

当使用b+树作为索引的存储数据结构时，当我们创建联合索引的时候，比如(column_1, column_2, column_3)，b+树建立索引是从左
到右来建立搜索树的，比如当我们来查询的时候``WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 3``。b+树会先通过最
左边的（建立索引的字段的左边的字段）字段，也就是``column_1``来确定下一步的查找对象，然后找到column_2，在通过column_2的
索引找到column_3。所以(column_2,column_3)这样的查询命中不到索引了。因为最左前缀，一定是从最左边的字段开始依次在b+树的子节点
查询，然后确定下一个查找的子节点的数据。所以我们(column_1)、(column_1,column_2)、(column_1,column_2,column_3)这三种查询
条件是可以使用到索引的。

#### 联合索引的存储结构

定义联合索引(员工级别，员工姓名，员工出生年月)，将联合索引按照索引顺序放入节点中，新插入节点时，先按照联合索引中的员工级别比较，如果相同会按照是员工姓名比较，如果员工级别和员工姓名都相同 最后是员工的出生年月比较。可以从图中从上到下，从左到右看，第一个B+树的节点 是通过联合索引的员工级别比较的，第二个节点是 员工级别相同，会按照员工姓名比较，第三个节点是  员工级别和员工姓名都相同，会按照员工出生年月比较。

<img src="../../img/b+_2.png" width = "700" height = "400" alt="联合索引" align=center />

#### 联合索引字段的先后顺序

我们定义多个字段的联合索引，会考虑到字段的先后顺序。那么字段的先后顺序真的会对查询的效率产生影响吗？比如上面的联合索引
``index test_column_1_column_2_column_3_index on test (column_1, column_2, column_3);``和``index test_column_1_column_2_column_3_index on test (column_2, column_1, column_3);``
在查询效率上有差别吗？我们试验下  
写个函数批量插入下数据  
````
CREATE PROCEDURE dowhile()
BEGIN
  DECLARE v1 INT DEFAULT 1000000000;

  WHILE v1 > 0 DO
    INSERT INTO test.test (column_1, column_2, column_3) VALUES (RAND() * 1000000000, RAND() * 10000, RAND() * 1000000000);
    SET v1 = v1 - 1;
END WHILE;
END;
````
我们插入了1000000000条数据，然后先设置索引(column_1, column_2, column_3)中column_1的数值范围为0到1000000000，column_2的范围为0到10000。
然后查询，看看这个索引的效率。数据量太大，插入的时间可能要好久。

#### b+树可以存储的数据条数

b+树 正常的高度是``（1~3）``一个整型``8b`` 指针占用``6b``，mysql页文件默认``16K``，``16k``的数据可以存储``16/14b=1170 ``
三层的数据大概就是``1170*1170*16=21902400``（千万条数据）所以千万级别的数据，对于建了索引的数据库查询的数据库也是很快的








### 参考
【最左匹配原则的理解】https://blog.csdn.net/u013164931/article/details/82386555  
【深入理解Mysql索引底层数据结构与算法】https://juejin.im/post/5d5c85d4f265da039f12ba97   