## 切片

- [什么是slice](#%e4%bb%80%e4%b9%88%e6%98%afslice)
   - [slice的创建使用](#slice%e7%9a%84%e5%88%9b%e5%bb%ba%e4%bd%bf%e7%94%a8)
   - [slice使用的一点规范](#slice%e4%bd%bf%e7%94%a8%e7%9a%84%e4%b8%80%e7%82%b9%e8%a7%84%e8%8c%83)
- [slice和数组的区别](#slice%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab)
- [slice的append是如何发生的](#slice%e7%9a%84append%e6%98%af%e5%a6%82%e4%bd%95%e5%8f%91%e7%94%9f%e7%9a%84)



### 什么是slice

Go中的切片，是我们经常用到的数据结构。有着比数组更灵活的用法，那么作者就去探究下什么是切片。

我们先来了解下切片的数据结构
````
type slice struct {
    array unsafe.Pointer // 指针
    len   int // 长度
    cap   int // 容量
}
````

切片一共三个属性：指针，指向底层的数组；长度，表示切片可用元素的个数，也就是说使用下标
对元素进行访问的时候，下标不能超过的长度；容量，底层数组的元素个数，容量》=长度。

![Aaron Swartz](https://github.com/zhan-liz/Go-POINT/blob/master/img/slice_1.png?raw=true)

底层的数组是可以被多个切片同时指向的，因此对一个切片元素的操作可能会影响到其他的切片。

#### slice的创建使用

|     序号      | 方式 |             代码示例                                          |
| ------------ | ------------ | -------------------------------                      |
| 1            |    直接声明   |   var slice []int                                    |
| 2            |    new       |   slice := *new([]int)                               |
| 3            |    字面量     |   slice := []int{1,2,3,4,5}                          |
| 4            |    make      |   slice := make([]int, 5, 10)                        |
| 5            |从切片或数组截取|   slice := array[1:5] 或 slice := sourceSlice[1:5]   |

第一种创建出来的 slice 其实是一个 nil slice。它的长度和容量都为0。和nil比较的结果为true。

这里比较混淆的是empty slice，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 0xc42003bda0。空切片和 nil 比较的结果为false。

下面是它的内部结构：
![Aaron Swartz](https://github.com/zhan-liz/Go-POINT/blob/master/img/slice_2.png?raw=true)

|     创建方式  |    nil切片               |             空切片                |
| ------------ | ------------------      | -------------------------------   |
| 方式一        |    var s1 []int         |  var s2 = []int{}                 |
| 方式二        |    var s4 = *new([]int) |  var s3 = make([]int, 0)          |
| 长度          |    0                    |     0                             |
| 容量          |    0                    |     0                             |
| 和nil比较      |true                     |   false                          |

nil 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 nil 切片。

- 字面量

直接初始化表达式进行创建

````
 s1 := []int{0, 1, 2, 3,5,6}
````

- make 
````
slice := make([]int, 5, 10) // 长度为5，容量为10
````

#### slice使用的一点规范

- 根据 Uber Go代码风格指南

- nil 是一个有效的 slice

`nil` 是一个长度为 0 的 slice。意思是，

- 使用 `nil` 来替代长度为 0 的 slice 返回

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  if x == "" {
    return []int{}
  }
  ```

  </td><td>

  ```go
  if x == "" {
    return nil
  }
  ```

  </td></tr>
  </tbody></table>

- 检查一个空 slice，应该使用 `len(s) == 0`，而不是 `nil`。

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  func isEmpty(s []string) bool {
    return s == nil
  }
  ```

  </td><td>

  ```go
  func isEmpty(s []string) bool {
    return len(s) == 0
  }
  ```

  </td></tr>
  </tbody></table>

- The zero value (a slice declared with `var`) is usable immediately without
  `make()`.

- 零值（通过 `var` 声明的 slice）是立马可用的，并不需要 `make()` 。

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  nums := []int{}
  // or, nums := make([]int)

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td><td>

  ```go
  var nums []int

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td></tr>
  </tbody></table>
  
## slice和数组的区别

slice的底层是数组，slice是对数组的封装，它描述一个数组的片段。两者都可以通过下标访问单个元素。

数组是定长的，长度定义好，不能改变。在Go中数组是不常见的，因为长度是类型的一部分，限制了它的表达
能力，比如[3]int 和 [4]int 就是不同的类型。

切片可以动态的扩容，非常灵活。切片的类型和长度没有关系。

## slice的append是如何发生的

先看看append函数的原型：

````
func append(slice []Type, elems ...Type) []Type
````
append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 ... 传入 slice，直接追加一个切片。

````
slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)
````
append函数返回值是一个新的slice，Go编译器不允许调用了append函数后不使用返回值。

````
append(slice, elem1, elem2)
append(slice, anotherSlice...)
````
上面是不能编译通过的

使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 len-1 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。

这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 slice 的容量是留了一定的 buffer 的。否则，每次添加元素的时候，都会发生迁移，成本太高。











### 参考
- 【快速理解Go数组和切片的内部实现原理】 https://i6448038.github.io/2018/08/11/array-and-slice-principle/
- 【GO代码风格指南 Uber Go】 https://github.com/uber-go/guide
- 【深度解密Go语言之Slice】 https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA    