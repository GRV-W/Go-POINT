## 切片

- [什么是slice](#%e4%bb%80%e4%b9%88%e6%98%afslice)
   - [slice的创建使用](#slice%e7%9a%84%e5%88%9b%e5%bb%ba%e4%bd%bf%e7%94%a8)
- [slice和数组的区别](#slice%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab)
- [slice的append是如何发生的](#slice%e7%9a%84append%e6%98%af%e5%a6%82%e4%bd%95%e5%8f%91%e7%94%9f%e7%9a%84)



### 什么是slice

Go中的切片，是我们经常用到的数据结构。有着比数组更灵活的用法，那么作者就去探究下什么是切片。

我们先来了解下切片的数据结构
````
type slice struct {
    array unsafe.Pointer // 指针
    len   int // 长度
    cap   int // 容量
}
````

切片一共三个属性：指针，指向底层的数组；长度，表示切片可用元素的个数，也就是说使用下标
对元素进行访问的时候，下标不能超过的长度；容量，底层数组的元素个数，容量》=长度。

![Aaron Swartz](https://github.com/zhan-liz/Go-POINT/blob/master/img/slice_1.png?raw=true)

底层的数组是可以被多个切片同时指向的，因此对一个切片元素的操作可能会影响到其他的切片。

#### slice的创建使用

|     序号      | 方式 |             代码示例                                          |
| ------------ | ------------ | -------------------------------                      |
| 1            |    直接声明   |   var slice []int                                    |
| 2            |    new       |   slice := *new([]int)                               |
| 3            |    字面量     |   slice := []int{1,2,3,4,5}                          |
| 4            |    make      |   slice := make([]int, 5, 10)                        |
| 5            |从切片或数组截取|   slice := array[1:5] 或 slice := sourceSlice[1:5]   |

第一种创建出来的 slice 其实是一个 nil slice。它的长度和容量都为0。和nil比较的结果为true。

这里比较混淆的是empty slice，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 0xc42003bda0。空切片和 nil 比较的结果为false。

下面是它的内部结构：
![Aaron Swartz](https://github.com/zhan-liz/Go-POINT/blob/master/img/slice_2.png?raw=true)

|     创建方式  |    nil切片               |             空切片                |
| ------------ | ------------------      | -------------------------------   |
| 方式一        |    var s1 []int         |  var s2 = []int{}                 |
| 方式二        |    var s4 = *new([]int) |  var s3 = make([]int, 0)          |
| 长度          |    0                    |     0                             |
| 容量          |    0                    |     0                             |
| 和nil比较      |true                     |   false                          |

nil 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 nil 切片。

- 根据 Uber Go代码风格指南

- nil 是一个有效的 slice

`nil` 是一个长度为 0 的 slice。意思是，

- 使用 `nil` 来替代长度为 0 的 slice 返回

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  if x == "" {
    return []int{}
  }
  ```

  </td><td>

  ```go
  if x == "" {
    return nil
  }
  ```

  </td></tr>
  </tbody></table>

- 检查一个空 slice，应该使用 `len(s) == 0`，而不是 `nil`。

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  func isEmpty(s []string) bool {
    return s == nil
  }
  ```

  </td><td>

  ```go
  func isEmpty(s []string) bool {
    return len(s) == 0
  }
  ```

  </td></tr>
  </tbody></table>

- The zero value (a slice declared with `var`) is usable immediately without
  `make()`.

- 零值（通过 `var` 声明的 slice）是立马可用的，并不需要 `make()` 。

  <table>
  <thead><tr><th>Bad</th><th>Good</th></tr></thead>
  <tbody>
  <tr><td>

  ```go
  nums := []int{}
  // or, nums := make([]int)

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td><td>

  ```go
  var nums []int

  if add1 {
    nums = append(nums, 1)
  }

  if add2 {
    nums = append(nums, 2)
  }
  ```

  </td></tr>
  </tbody></table>


 
 




### 参考
- 【快速理解Go数组和切片的内部实现原理】 https://i6448038.github.io/2018/08/11/array-and-slice-principle/
- 【GO代码风格指南 Uber Go】 https://github.com/uber-go/guide
- 【深度解密Go语言之Slice】 https://mp.weixin.qq.com/s/MTZ0C9zYsNrb8wyIm2D8BA    