## 切片

- [什么是slice](#%e4%bb%80%e4%b9%88%e6%98%afslice)
   - [slice的创建使用](#slice%e7%9a%84%e5%88%9b%e5%bb%ba%e4%bd%bf%e7%94%a8)
- [slice和数组的区别](#slice%e5%92%8c%e6%95%b0%e7%bb%84%e7%9a%84%e5%8c%ba%e5%88%ab)
- [slice的append是如何发生的](#slice%e7%9a%84append%e6%98%af%e5%a6%82%e4%bd%95%e5%8f%91%e7%94%9f%e7%9a%84)



### 什么是slice

Go中的切片，是我们经常用到的数据结构。有着比数组更灵活的用法，那么作者就去探究下什么是切片。

我们先来了解下切片的数据结构
````
type slice struct {
    array unsafe.Pointer // 指针
    len   int // 长度
    cap   int // 容量
}
````

切片一共三个属性：指针，指向底层的数组；长度，表示切片可用元素的个数，也就是说使用下标
对元素进行访问的时候，下标不能超过的长度；容量，底层数组的元素个数，容量》=长度。

![Aaron Swartz](https://github.com/zhan-liz/Go-POINT/blob/master/img/slice_1.png?raw=true)

底层的数组是可以被多个切片同时指向的，因此对一个切片元素的操作可能会影响到其他的切片。

#### slice的创建使用

|     序号      | 方式 |             代码示例                                          |
| ------------ | ------------ | -------------------------------                      |
| 1            |    直接声明   |   var slice []int                                    |
| 2            |    new       |   slice := *new([]int)                               |
| 3            |    字面量     |   slice := []int{1,2,3,4,5}                          |
| 4            |    make      |   slice := make([]int, 5, 10)                        |
| 5            |从切片或数组截取|   slice := array[1:5] 或 slice := sourceSlice[1:5]   |

第一种创建出来的 slice 其实是一个 nil slice。它的长度和容量都为0。和nil比较的结果为true。

这里比较混淆的是empty slice，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 0xc42003bda0。空切片和 nil 比较的结果为false。

![Aaron Swartz](https://github.com/zhan-liz/Go-POINT/blob/master/img/slice_2.png?raw=true)


### 参考
【快速理解Go数组和切片的内部实现原理】 https://i6448038.github.io/2018/08/11/array-and-slice-principle/
